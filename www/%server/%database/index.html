import math

import pymongo


MB = 1024 ** 2.0


def f2s(n, scale=1.0):
    """Given float, return str.
    """
    if n == 0.0:
        out = "0&nbsp;&nbsp;"
    else:
        out = "%.01f" % (n / scale)

        # add commas -- 1,000.00
        whole, fraction = out.split('.')
        _whole = []
        for i, digit in enumerate(reversed(whole), start=1):
            _whole.insert(0, digit)
            if i % 3 == 0:
                _whole.insert(0, ',')
        out = ''.join(_whole + ['.', fraction]).lstrip(',')

    return out


class Collection(object):
    """Model a MongoDB collection.
    """

    is_index = False

    def __init__(self, db, collname):
        self.name = collname
        self.stats = stats = db.command({'collStats': collname})
        self.storage_size = float(stats['storageSize'])
        self.data_size = float(stats['size'])

        # I adapted this from the definition of db.foo.totalSize per the mongo
        # js shell. I gather from there that indexes are just specially-named
        # collections, and the same storageSize/dataSize semantics apply. I
        # believe that the indexSizes attribute of collStats gives us dataSize.
        index_names = stats['indexSizes'].keys()
        self.indices = ["%s.$%s" % (collname, name) for name in index_names]

    def format_storage_size(self, dbsize):
        total = f2s(dbsize, MB).replace("&nbsp;", "N")

        absolute = f2s(self.storage_size, MB)
        absolute = absolute.replace("&nbsp;", "N")
        absolute = ("&nbsp;" * (len(total) - len(absolute))) + absolute
        absolute = absolute.replace("N", "&nbsp;")
        absolute = "%s&nbsp;&nbsp;&nbsp;" % absolute

        percent = f2s(self.storage_size / dbsize * 100)
        percent = ((7 - len(percent)) * "&nbsp;") + percent

        return absolute + percent

    def format_data_size(self, dbsize):
        """Return a string indicating dataSize.
        """
        out = f2s(self.data_size / dbsize * 100)
        out = out.replace("&nbsp;", "N")
        out = ("&nbsp;" * (5 - len(out))) + out
        out = out.replace("N", "&nbsp;")
        return out


class Index(Collection):
    """MongoDB indices are special collections.

    The storageSize and dataSize semantics appear to be the same, so all of the
    logic of the base class applies. We just want to format them differently in
    the UI.

    """
    is_index = True

# ========================================================================== ^L


# parse and hydrate
# =================

server = request.path['server']
database = request.path['database']
db = pymongo.Connection(server, slave_okay=True)[database]


# dbsize
# ======
# We need the disk size of the database as a whole in order to calculate
# percentages. However, the dbstats call blocks the whole db server while it
# runs, and it takes a long time (we killed it after 15 minutes in the case
# where this problem came to light. Oops!). See:
#
#   http://www.mongodb.org/display/DOCS/Monitoring+and+Diagnostics#MonitoringandDiagnostics-mongoShellDiagnosticCommands
#
# Now instead we sum storageSize from collstats, which is a safe call (per
# jaraco). Apparently there are three size metrics, however, and I'm not sure
# that summing collstats.storageSize is guaranteed to equal dbstats.fileSize
# (which is what I want). Here's me trying to figure out what to do:
#
#   http://stackoverflow.com/questions/10339852/
#
# The bottom line for now is that I'm showing storageSize and dataSize and 
# pretending not to care about fileSize (though of course that's the very thing
# I care about!).

dbsize = 0.0


# rows
# ====
# We have to build this as a list rather than using a generator because we need
# to fully compute dbsize before formatting any given row for display. We also 
# take pains to sort by storage_size of the collection, while grouping indices
# under their collection.

rows = []
collnames = db.collection_names() # XXX might be expensive

# first build a list of collections, sorted by storage_size ascending
for collname in collnames:
    collection = Collection(db, collname)
    rows.append(collection)
    dbsize += collection.storage_size
rows.sort(key=lambda row: row.storage_size)

# now add in indices, reversing in the process
_rows = []
while rows:
    collection = rows.pop()  # this has the effect of reversing rows
    _rows.append(collection)
    for indexname in collection.indices:
        index = Index(db, indexname)
        _rows.append(index)
        dbsize += index.storage_size
rows = _rows


# ========================================================================== ^L
{% extends "base.html" %}
{% block content %}
<style>
    TR.collection TD.notfirst {
        border-top: none ! important;
        padding: 0 1em 0 10px ! important;
    }
    TR.collection TD {
        padding-bottom: 0 ! important;
    }
    TR.collection TD.name {
        width: 1px;
    }
    TD.storage_size, TD.data_size {
        width: 1px;
        padding-right: 1em ! important;
        padding-left: 10px;
        font: normal 10pt/12pt "Lucida Mono", Monaco, monospace;
        text-align: right;
        white-space: nowrap;
        font-weight: normal ! important;
    }
    TR.server TD.storage_size, 
    TR.server TD.data_size, 
    TR.database TD.data_size {
        padding-left: 0 ! important;
        padding-right: 0 ! important;
        text-align: center;
    }
    TR.collection TD.data_size {
        text-align: center;
    }
    TD.empty {
        width: 100%;
    }
    .index {
        color: #CCC;
    }
</style>
<table>
    <tr class="big server">
        <th><a href="/" title="Click for All Servers">Server</a></th>
        <td>{{ server }}</td>
        <td class="storage_size">storageSize</td>
        <td class="data_size">dataSize</td>
        <td class="empty"></td>
    </tr>
    <tr class="big database">
        <th><a href="/{{ server }}/" title="Click for All Databases">Database</a></th>
        <td>{{ database }}</td>
        <td class="storage_size">{{ f2s(dbsize, MB) }} MB&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;</td>
        <td class="data_size">%</td>
        <td class="empty"></td>
    </tr>
    {% for i, row in enumerate(rows) %}
    <tr class="big collection listing{% if row.is_index %} index{% end %}">
        {% if i == 0 %}<th rowspan="{{ len(rows) }}">
            <span>
                Collections
                <span class="note">
                    and indices<br />
                    <br />
                    All percentages use<br />
                    total storageSize<br />
                    as the base</span>
            </span>
        </th>{% end %}

        <td class="name{% if i > 0 %} notfirst{% end %}">{% if not row.is_index %}<a 
            href="/{{ server }}/{{ database }}/{{ row.name }}/">{% end %}{{ row.name }}{% if not row.is_index %}</
            a>{% end %}</td>
        <td class="storage_size{% if i > 0 %} notfirst{% end %}">{{ row.format_storage_size(dbsize) }}</td>
        <td class="data_size{% if i > 0 %} notfirst{% end %}">{{ row.format_data_size(dbsize) }}</td>
        <td class="empty{% if i > 0 %} notfirst{% end %}"></td>
    </tr>
    {% end %}
</table>
{% end %}
